package main

// 고루틴은 경량 스레드. 스레드란 천공 뚫은 명령카드 다발. 프로세스는 하나 이상의 논리적 스레드로 구성.
// 하나의 코어가 빠르게 여러 스레드를 돌아가면서 실행하면 마치 여러개의 프로세스가 동시에 돌아가는 것처럼 보인다. 멀티태스킹.
// 코어가 스레드 사이를 돌아가는 것을 컨택스트 스위칭이라 부르고, 그 때는 컨텍스트 스위칭 비용이 발생한다. 명령의 문맥(명령 포인터 등. 컨텍스트라 부른다)을 저장해야하기 때문.
// 모든 프로그램은 고루틴을 하나 이상 가지고 있다. main 루틴을 가지고 있기 때문. 이 고루틴은 main함수와 같이 시작되고 종료된다.
// 추가 고루틴은, go Function()으로 생성할 수 있다.
// 다만, 추가 고루틴으로 함수를 실행하는 동안 main 루틴이 끝나서는 안된다. 그래서 기다려야 하는데, time.Spleep()을 적당히 해도 되지만
// 메인 루틴이 얼마나 기다려야 하는지 계산하기 어려우므로, sync 패키지의 WaitGroup 객체와 Add,Done,Wait 함수를 쓴다.

// os스레드를 직접 사용하는 다른 언어에서는 os스레드의 개수가 많아지면 결국 컨텍스트 스위칭을 해야하고, 이는 컨텍스트 스위칭 비용의 증가로 이어진다.
// 하지만 고루틴의 경우, 각 코어와 연결된 os스레드는 가만히 있고, os스레드와 연결된 고루틴만 바뀌기 때문에 컨텍스트 스위칭 비용이 발생하지 않는다.
// 시스템 콜의 호출(네트워크 기능으로 인한 대기 상태 등)시 해당 고루틴은 대기상태로 두고, 다른 고루틴을 os스레드와 연결시켜버리면 컨텍스트 비용도 발생하지 않으면서
// 효율적으로 멀티스레딩 연산을 할 수 있다.

import (
	"fmt"
	"sync"
)

var wg sync.WaitGroup

func Sum(a, b int) {
	sum := 0
	for i := a; i <= b; i++ {
		sum += i
	}
	// 끝났으면 Done()
	wg.Done()
	fmt.Println("done")
}

func main() {

	//총 작업 개수 설정
	wg.Add(10)
	for i := 0; i <= 9; i++ {
		Sum(1, 100_0000_0000)
	}

	// 메인 루틴은 나머지 고루틴이 끝날 때까지 기다려야한다. main()이 끝나면 프로그램이 종료되어버리기 때문.
	wg.Wait()
}
